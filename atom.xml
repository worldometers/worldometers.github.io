<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XtestW&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xtestw.com/"/>
  <updated>2019-08-04T15:04:43.685Z</updated>
  <id>http://xtestw.com/</id>
  
  <author>
    <name>xtestw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://xtestw.com/2019/08/03/GraphQl-%E4%BD%BF%E7%94%A8-java/"/>
    <id>http://xtestw.com/2019/08/03/GraphQl-使用-java/</id>
    <published>2019-08-03T06:26:05.000Z</published>
    <updated>2019-08-04T15:04:43.685Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年在做内容库的时候，涉及到了多系统多数据源互相查询的情景，当时就想要将内容库的所有数据，增加统一的数据接入层，通过graphql的方式提供给上层业务使用，后面受限于人力没有实施。目前从头开始做站群相关的业务，顺带着浅尝了一下graphql，感觉还不错。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="GraphQL" scheme="http://xtestw.com/categories/GraphQL/"/>
    
      <category term="Java" scheme="http://xtestw.com/categories/GraphQL/Java/"/>
    
      <category term="New Skill" scheme="http://xtestw.com/categories/GraphQL/Java/New-Skill/"/>
    
    
      <category term="graphql, graphiql, github" scheme="http://xtestw.com/tags/graphql-graphiql-github/"/>
    
  </entry>
  
  <entry>
    <title>HttpURLConnection使用http代理</title>
    <link href="http://xtestw.com/2017/08/13/httpurlconnection-e4-bd-bf-e7-94-a8http-e4-bb-a3-e7-90-86/"/>
    <id>http://xtestw.com/2017/08/13/httpurlconnection-e4-bd-bf-e7-94-a8http-e4-bb-a3-e7-90-86/</id>
    <published>2017-08-13T14:38:08.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工程中的网络请求，有时会需要使用http代理，比较简单的方法是使用apache的httpclient 直接设置代理，但有的时候使用java自带的HttpURLConnection的时候，就需要注意多线程的问题了。 使用HttpURLConnection 实现代理的方法也很简
      
    
    </summary>
    
      <category term="JAVA" scheme="http://xtestw.com/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>sdk篡改</title>
    <link href="http://xtestw.com/2017/07/23/sdk-e7-af-a1-e6-94-b9/"/>
    <id>http://xtestw.com/2017/07/23/sdk-e7-af-a1-e6-94-b9/</id>
    <published>2017-07-23T12:51:22.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间，因为一年前篡改了一个sdk的包，导致了一系列不可预知的损失，这也充分说明了技术的正确性，需要决策的正确性来支撑的。作为技术人员，不仅仅要考虑技术的可行性，也要考虑实施后的风险和结果的预期假设。 从工程角度，简单记录一下篡改sdk包的技术。 1. 解压jar或者ap
      
    
    </summary>
    
      <category term="JAVA" scheme="http://xtestw.com/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA整理</title>
    <link href="http://xtestw.com/2016/05/24/rsa-e6-95-b4-e7-90-86/"/>
    <id>http://xtestw.com/2016/05/24/rsa-e6-95-b4-e7-90-86/</id>
    <published>2016-05-24T15:17:24.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近的论文用到了RSA相关的东西，做一个整理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#toc_0&quot;&gt;RSA&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#toc_1&quot;&gt;流程图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#toc_2&quot;&gt;选取2个质数p、q&lt;/a&gt;&lt;/l
      
    
    </summary>
    
      <category term="Theory" scheme="http://xtestw.com/categories/Theory/"/>
    
    
      <category term="RSA" scheme="http://xtestw.com/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>c++对象模型</title>
    <link href="http://xtestw.com/2016/05/05/cplusplusobjectmodel/"/>
    <id>http://xtestw.com/2016/05/05/cplusplusobjectmodel/</id>
    <published>2016-05-04T16:22:50.000Z</published>
    <updated>2019-07-29T15:22:50.130Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看《深度探索c++对象模型》对于对象模型有了一点了解，做一个总结。以下的一些结论的实验见：&lt;a href=&quot;https://github.com/xtestw/CPPObjModelTest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
      <category term="C++" scheme="http://xtestw.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 技巧：让进程在后台可靠运行的几种方法</title>
    <link href="http://xtestw.com/2016/01/29/linuxrunonbackground/"/>
    <id>http://xtestw.com/2016/01/29/linuxrunonbackground/</id>
    <published>2016-01-29T07:18:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-cn-nohup/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ibm.com/developerworks/cn/l
      
    
    </summary>
    
      <category term="Linux" scheme="http://xtestw.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>x&amp;(-x)取x的最后一个1的证明</title>
    <link href="http://xtestw.com/2015/04/22/proof/"/>
    <id>http://xtestw.com/2015/04/22/proof/</id>
    <published>2015-04-22T10:49:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;明天要给新队员讲树状数组，避不开的一个证明，之前教主讲过，当时没听明白给忘了- -，只有自己想了一种证明方法。 #####证明##### 大家都知道，计算机是用补码来存储一个数的，在这种编码情况下，整数是自然状态编码，假设我们是一个5位的机器（只是假设），那么1，编码就为0
      
    
    </summary>
    
      <category term="ACMICPC" scheme="http://xtestw.com/categories/ACMICPC/"/>
    
    
  </entry>
  
  <entry>
    <title>c++ 子类要正确的调用父类构造函数</title>
    <link href="http://xtestw.com/2015/04/05/cplusplus/"/>
    <id>http://xtestw.com/2015/04/05/cplusplus/</id>
    <published>2015-04-04T22:36:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;class base{&lt;br&gt;    public:&lt;br&gt;        int i,j;&lt;br&gt;        base(){&lt;br&gt;            i=j=0;&lt;br&gt;        }&lt;br&gt;        base(int a,int b){&lt;br&gt;   
      
    
    </summary>
    
      <category term="C++" scheme="http://xtestw.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>c++ 默认构造函数</title>
    <link href="http://xtestw.com/2015/04/03/c-e9-bb-98-e8-ae-a4-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0/"/>
    <id>http://xtestw.com/2015/04/03/c-e9-bb-98-e8-ae-a4-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0/</id>
    <published>2015-04-03T05:37:00.000Z</published>
    <updated>2019-07-29T15:22:50.130Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;关于c++构造函数两个误解&lt;/strong&gt; 1.任何class只要没有定义构造函数，就会被编译器自动合成一个。 有些构造函数在实际中有和没有是没有任何用处的，所以无用的构造函数是不会被构建出来 2.编译器合成的构造函数，会为每个成员变量设定初始值 在我看来
      
    
    </summary>
    
      <category term="C++" scheme="http://xtestw.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>hibernate ID 生成方式</title>
    <link href="http://xtestw.com/2015/02/10/hibernateid-e7-94-9f-e6-88-90-e6-96-b9-e5-bc-8f/"/>
    <id>http://xtestw.com/2015/02/10/hibernateid-e7-94-9f-e6-88-90-e6-96-b9-e5-bc-8f/</id>
    <published>2015-02-10T05:08:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、assigned&quot;&gt;&lt;a href=&quot;#1、assigned&quot; class=&quot;headerlink&quot; title=&quot;1、assigned&quot;&gt;&lt;/a&gt;1、assigned&lt;/h1&gt;&lt;p&gt;主键由外部程序负责生成，在 save() 之前必须指定一个。Hibernat
      
    
    </summary>
    
      <category term="JAVA" scheme="http://xtestw.com/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>windows核心编程-错误处理</title>
    <link href="http://xtestw.com/2015/01/29/windows-e6-a0-b8-e5-bf-83-e7-bc-96-e7-a8-8b-e9-94-99-e8-af-af-e5-a4-84-e7-90-86/"/>
    <id>http://xtestw.com/2015/01/29/windows-e6-a0-b8-e5-bf-83-e7-bc-96-e7-a8-8b-e9-94-99-e8-af-af-e5-a4-84-e7-90-86/</id>
    <published>2015-01-29T06:04:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.常见的错误返回类型&lt;/p&gt;
&lt;p&gt;VOID/BOOL/HANDLE/PVOID/LONG/DWORD VOID 不可能失败 BOOL 错误返回false 编码的时候最好测试是否不为FALSE HANDLE 错误 NULL/INVALID_HANDLE_VALUE PVO
      
    
    </summary>
    
      <category term="ACMICPC" scheme="http://xtestw.com/categories/ACMICPC/"/>
    
    
  </entry>
  
  <entry>
    <title>IOCP</title>
    <link href="http://xtestw.com/2015/01/29/iocp/"/>
    <id>http://xtestw.com/2015/01/29/iocp/</id>
    <published>2015-01-29T05:41:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IOCP是windows下的一种异步IO通信模式（linux下面对应epoll，二者有区别—&amp;gt;&lt;a href=&quot;http://www.cnblogs.com/uzhang/archive/2012/02/24/2365980.html）&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Theory" scheme="http://xtestw.com/categories/Theory/"/>
    
    
  </entry>
  
  <entry>
    <title>Xchart 源码分析（1）</title>
    <link href="http://xtestw.com/2014/12/22/xchart-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-ef-bc-881-ef-bc-89/"/>
    <id>http://xtestw.com/2014/12/22/xchart-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-ef-bc-881-ef-bc-89/</id>
    <published>2014-12-21T23:04:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;学校课程需要找一份代码，来讲讲代码里面用了哪些设计模式\- -！ 还是要java的。。。 于是上github上面翻代码，偶然翻到一个java的xchart图标库，感觉可能以后会用的到，而且代码不是很长，就直接拿过来用了。具体的链接地址如下：[https://
      
    
    </summary>
    
      <category term="SourceReading" scheme="http://xtestw.com/categories/SourceReading/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="http://xtestw.com/2014/09/08/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e4-bb-a3-e7-90-86-e6-a8-a1-e5-bc-8f/"/>
    <id>http://xtestw.com/2014/09/08/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e4-bb-a3-e7-90-86-e6-a8-a1-e5-bc-8f/</id>
    <published>2014-09-08T01:11:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实际开发的时候，我们同样的一个对象，对于不同的客户，可能能够调用的方法是不一样的，就是权限的控制，这个时候，对象的方法都应该是public，那么就要给对象加上一层，通过客户的类型，决定是否可以访问，也就是说，客户不直接访问对象，而是访问给对象加上的这一层，就是代理层。&lt;/
      
    
    </summary>
    
      <category term="Design Pattern" scheme="http://xtestw.com/categories/Design-Pattern/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://xtestw.com/2014/09/07/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e7-8a-b6-e6-80-81-e6-a8-a1-e5-bc-8f/"/>
    <id>http://xtestw.com/2014/09/07/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e7-8a-b6-e6-80-81-e6-a8-a1-e5-bc-8f/</id>
    <published>2014-09-07T05:18:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;状态模式是针对系统的状态转换的，其主要的定义如下：&lt;/p&gt;
&lt;p&gt;状态模式：允许对象在内部状态改变时改变他的行为，对象看起来好像修改了它的类。&lt;/p&gt;
&lt;p&gt;为了方便状态转移 我们为状态定义一个通用的接口，然后每一种状态都实现这个接口，而在系统类中，通过构造函数，将系统本身
      
    
    </summary>
    
      <category term="Design Pattern" scheme="http://xtestw.com/categories/Design-Pattern/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-迭代器模式和组合模式</title>
    <link href="http://xtestw.com/2014/09/06/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e8-bf-ad-e4-bb-a3-e5-99-a8-e6-a8-a1-e5-bc-8f-e5-92-8c-e7-bb-84-e5-90-88-e6-a8-a1-e5-bc-8f/"/>
    <id>http://xtestw.com/2014/09/06/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e8-bf-ad-e4-bb-a3-e5-99-a8-e6-a8-a1-e5-bc-8f-e5-92-8c-e7-bb-84-e5-90-88-e6-a8-a1-e5-bc-8f/</id>
    <published>2014-09-05T20:52:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.迭代器模式完成的功能是和迭代器一样的，封装了对对象的顺序遍历，因为子类的对象集合的存储方式可能并不一致。但是存储的对象是一致的。&lt;/p&gt;
&lt;p&gt;public classItem{&lt;br&gt;    …..//各种属性&lt;br&gt;}&lt;br&gt;public class Set1{&lt;b
      
    
    </summary>
    
      <category term="Design Pattern" scheme="http://xtestw.com/categories/Design-Pattern/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法</title>
    <link href="http://xtestw.com/2014/09/05/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e6-a8-a1-e6-9d-bf-e6-96-b9-e6-b3-95/"/>
    <id>http://xtestw.com/2014/09/05/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e6-a8-a1-e6-9d-bf-e6-96-b9-e6-b3-95/</id>
    <published>2014-09-04T19:36:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面学习过了策略模式，策略模式是对一类的算法进行封装，利用组合，算法之间可以互相替换，但是这个是针对算法过程不是一样的算法。但是如果一系列的算法的步骤都是一样的，且算法的很多过程都是一样的处理，那么，用策略模式的话，会导致算法的重用不高，我们采用模板方法来实现：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Design Pattern" scheme="http://xtestw.com/categories/Design-Pattern/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式和外观模式</title>
    <link href="http://xtestw.com/2014/09/04/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e9-80-82-e9-85-8d-e5-99-a8-e6-a8-a1-e5-bc-8f-e5-92-8c-e5-a4-96-e8-a7-82-e6-a8-a1-e5-bc-8f/"/>
    <id>http://xtestw.com/2014/09/04/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e9-80-82-e9-85-8d-e5-99-a8-e6-a8-a1-e5-bc-8f-e5-92-8c-e5-a4-96-e8-a7-82-e6-a8-a1-e5-bc-8f/</id>
    <published>2014-09-03T21:46:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.适配器模式 适配器模式是针对接口不一时处理的情况，比如我的类的参数是IInterface1，但是我现在想要调用IInterface2接口的函数，怎么办呢？就是用适配器来解决这个问题：&lt;/p&gt;
&lt;p&gt;public interface IInterface1(){&lt;br&gt; 
      
    
    </summary>
    
      <category term="Design Pattern" scheme="http://xtestw.com/categories/Design-Pattern/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-命令模式</title>
    <link href="http://xtestw.com/2014/09/03/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e5-91-bd-e4-bb-a4-e6-a8-a1-e5-bc-8f/"/>
    <id>http://xtestw.com/2014/09/03/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e5-91-bd-e4-bb-a4-e6-a8-a1-e5-bc-8f/</id>
    <published>2014-09-02T21:26:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;命令模式这个设计模式更像是对接口编程的一种应用，比如给小朋友穿衣服，但是不一样的衣服有不一样的穿法，裤子，衬衫，鞋，T恤都是不一样的，但是小朋友不知道怎么穿，只知道想穿什么，那么怎么办呢，小朋友会让他的妈妈帮他穿，这里面的“让妈妈帮忙”，就是给妈妈一个命令（虽然不是很恰当-
      
    
    </summary>
    
      <category term="Design Pattern" scheme="http://xtestw.com/categories/Design-Pattern/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-单件模式</title>
    <link href="http://xtestw.com/2014/09/02/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e5-8d-95-e4-bb-b6-e6-a8-a1-e5-bc-8f/"/>
    <id>http://xtestw.com/2014/09/02/e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f-e5-8d-95-e4-bb-b6-e6-a8-a1-e5-bc-8f/</id>
    <published>2014-09-01T22:42:00.000Z</published>
    <updated>2019-07-29T15:22:50.131Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工程中，某些对象我们只需要一个，比如线程池，缓存，对话框等的对象，我们通常的做法是可以定一个全局静态变量，然后通过程序初始化的时候就实例化他们，然后直接调用这个全局变量，但是这样有个问题，如果我的这个对象消耗的资源很多，而有的时候，我的程序在运行过程中又没用到这个对象，岂不
      
    
    </summary>
    
      <category term="Design Pattern" scheme="http://xtestw.com/categories/Design-Pattern/"/>
    
    
  </entry>
  
</feed>
